From 0c3624c240d78fc3a677d8d0286b3e0b5f6ae281 Mon Sep 17 00:00:00 2001
From: Lennart Poettering <lennart@poettering.net>
Date: Tue, 29 Jul 2008 22:33:12 +0200
Subject: [PATCH] add sound sample cache plugin that drops cached samples from pulseaudio


Signed-off-by: Lennart Poettering <lennart@poettering.net>
---
 configure.ac                                       |   26 ++
 data/gnome-settings-daemon.schemas.in              |   23 +
 plugins/Makefile.am                                |    1 +
 plugins/sound-sample-cache/Makefile.am             |   42 ++
 .../gsd-sound-sample-cache-manager.c               |  471 ++++++++++++++++++++
 .../gsd-sound-sample-cache-manager.h               |   57 +++
 .../gsd-sound-sample-cache-plugin.c                |  100 +++++
 .../gsd-sound-sample-cache-plugin.h                |   59 +++
 .../sound-sample-cache.gnome-settings-plugin.in    |    8 +
 9 files changed, 787 insertions(+), 0 deletions(-)
 create mode 100644 plugins/sound-sample-cache/Makefile.am
 create mode 100644 plugins/sound-sample-cache/gsd-sound-sample-cache-manager.c
 create mode 100644 plugins/sound-sample-cache/gsd-sound-sample-cache-manager.h
 create mode 100644 plugins/sound-sample-cache/gsd-sound-sample-cache-plugin.c
 create mode 100644 plugins/sound-sample-cache/gsd-sound-sample-cache-plugin.h
 create mode 100644 plugins/sound-sample-cache/sound-sample-cache.gnome-settings-plugin.in

diff --git a/configure.ac b/configure.ac
index 1dbd3d9..c921f66 100644
--- a/configure.ac
+++ b/configure.ac
@@ -236,6 +236,30 @@ AC_SUBST(ESD_LIBS)
 AC_SUBST(ESD_LOCATION)
 
 dnl ==============================================
+dnl PulseAudio section
+dnl ==============================================
+
+AC_ARG_ENABLE(pulse,
+  AC_HELP_STRING([--disable-pulse],
+                 [turn off PulseAudio support]),
+       [case "${enableval}" in
+               yes) WANT_PULSE=yes ;;
+               no)  WANT_PULSE=no ;;
+               *) AC_MSG_ERROR(bad value ${enableval} for --disable-pulse) ;;
+       esac],
+       [WANT_PULSE=yes]) dnl Default value
+
+if test x$WANT_PULSE = xyes ; then
+       PKG_CHECK_MODULES(PULSE, libpulse >= 0.9.11,
+	       AC_DEFINE(HAVE_PULSE, 1, [Define if PULSE sound server should be used]),
+               AC_MSG_RESULT([disabled]))
+fi
+
+AC_SUBST(PULSE_CFLAGS)
+AC_SUBST(PULSE_LIBS)
+AC_SUBST(PULSE_LOCATION)
+
+dnl ==============================================
 dnl GStreamer section
 dnl ==============================================
 GST_MAJORMINOR=auto
@@ -444,6 +468,7 @@ plugins/mouse/Makefile
 plugins/screensaver/Makefile
 plugins/sound/Makefile
 plugins/sound/libsounds/Makefile
+plugins/sound-sample-cache/Makefile
 plugins/typing-break/Makefile
 plugins/xrandr/Makefile
 plugins/xrdb/Makefile
@@ -485,6 +510,7 @@ echo "
         ALSA support:             ${have_alsa}
         GStreamer support:        ${have_gstreamer}
         ESD support:              ${WANT_ESD}
+        PulseAudio support:       ${WANT_PULSE}
 
         Profiling support:        ${enable_profiling}
 "
diff --git a/data/gnome-settings-daemon.schemas.in b/data/gnome-settings-daemon.schemas.in
index 3f6a426..6efb1f0 100644
--- a/data/gnome-settings-daemon.schemas.in
+++ b/data/gnome-settings-daemon.schemas.in
@@ -233,6 +233,29 @@
     </schema>
 
     <schema>
+      <key>/schemas/apps/gnome_settings_daemon/plugins/sound-sample-cache/active</key>
+      <applyto>/apps/gnome_settings_daemon/plugins/sound-sample-cache/active</applyto>
+      <owner>gnome-settings-daemon</owner>
+      <type>bool</type>
+      <default>TRUE</default>
+      <locale name="C">
+        <short>Enable sound sample cache plugin</short>
+        <long>Set to True to enable the plugin to manage sound sample caches.</long>
+      </locale>
+    </schema>
+    <schema>
+      <key>/schemas/apps/gnome_settings_daemon/plugins/sound-sample-cache/priority</key>
+      <applyto>/apps/gnome_settings_daemon/plugins/sound-sample-cache/priority</applyto>
+      <owner>gnome-settings-daemon</owner>
+      <type>int</type>
+      <default>5</default>
+      <locale name="C">
+        <short></short>
+        <long></long>
+      </locale>
+    </schema>
+
+    <schema>
       <key>/schemas/apps/gnome_settings_daemon/plugins/sound/active</key>
       <applyto>/apps/gnome_settings_daemon/plugins/sound/active</applyto>
       <owner>gnome-settings-daemon</owner>
diff --git a/plugins/Makefile.am b/plugins/Makefile.am
index 2d33061..9275969 100644
--- a/plugins/Makefile.am
+++ b/plugins/Makefile.am
@@ -18,4 +18,5 @@ SUBDIRS =		\
 	xrandr		\
 	xrdb		\
 	xsettings	\
+	sound-sample-cache \
 	$(NULL)
diff --git a/plugins/sound-sample-cache/Makefile.am b/plugins/sound-sample-cache/Makefile.am
new file mode 100644
index 0000000..844829c
--- /dev/null
+++ b/plugins/sound-sample-cache/Makefile.am
@@ -0,0 +1,42 @@
+plugin_LTLIBRARIES = \
+	libsound-sample-cache.la
+
+libsound_sample_cache_la_SOURCES = \
+	gsd-sound-sample-cache-plugin.h \
+	gsd-sound-sample-cache-plugin.c \
+	gsd-sound-sample-cache-manager.h \
+	gsd-sound-sample-cache-manager.c
+
+libsound_sample_cache_la_CPPFLAGS = \
+	-I$(top_srcdir)/gnome-settings-daemon \
+	-DGNOME_SETTINGS_LOCALEDIR=\""$(datadir)/locale"\" \
+	$(AM_CPPFLAGS)
+
+libsound_sample_cache_la_CFLAGS = \
+	$(SETTINGS_PLUGIN_CFLAGS) \
+	$(GNOME_CFLAGS)	\
+	$(PULSE_CFLAGS)	\
+	$(AM_CFLAGS)
+
+libsound_sample_cache_la_LDFLAGS = \
+	$(GSD_PLUGIN_LDFLAGS)
+
+libsound_sample_cache_la_LIBADD = \
+	$(SETTINGS_PLUGIN_LIBS)	\
+	$(PULSE_LIBS)
+
+plugin_in_files = \
+	sound-sample-cache.gnome-settings-plugin.in
+
+plugin_DATA = $(plugin_in_files:.gnome-settings-plugin.in=.gnome-settings-plugin)
+
+EXTRA_DIST = \
+	$(plugin_in_files)
+
+CLEANFILES = \
+	$(plugin_DATA)
+
+DISTCLEANFILES = \
+	$(plugin_DATA)
+
+@GSD_INTLTOOL_PLUGIN_RULE@
diff --git a/plugins/sound-sample-cache/gsd-sound-sample-cache-manager.c b/plugins/sound-sample-cache/gsd-sound-sample-cache-manager.c
new file mode 100644
index 0000000..5acf1e2
--- /dev/null
+++ b/plugins/sound-sample-cache/gsd-sound-sample-cache-manager.c
@@ -0,0 +1,471 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2008 Lennart Poettering <lennart@poettering.net>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#include "config.h"
+
+#include <sys/types.h>
+#include <sys/wait.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <unistd.h>
+#include <string.h>
+#include <errno.h>
+
+#include <locale.h>
+
+#include <glib.h>
+#include <glib/gi18n.h>
+#include <gconf/gconf-client.h>
+#include <gtk/gtk.h>
+
+#ifdef HAVE_PULSE
+#include <pulse/pulseaudio.h>
+#endif
+
+#include "gsd-sound-sample-cache-manager.h"
+#include "gnome-settings-profile.h"
+
+#define GSD_SOUND_SAMPLE_CACHE_MANAGER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE((o), GSD_TYPE_SOUND_SAMPLE_CACHE_MANAGER, GsdSoundSampleCacheManagerPrivate))
+
+struct GsdSoundSampleCacheManagerPrivate
+{
+        guint gconf_notify;
+        GList* monitors;
+        guint timeout;
+};
+
+#define GCONF_SOUND_DIR "/desktop/gnome/sound"
+
+static void gsd_sound_sample_cache_manager_class_init(GsdSoundSampleCacheManagerClass *klass);
+static void gsd_sound_sample_cache_manager_init(GsdSoundSampleCacheManager *sound_manager);
+static void gsd_sound_sample_cache_manager_finalize(GObject *object);
+
+G_DEFINE_TYPE(GsdSoundSampleCacheManager, gsd_sound_sample_cache_manager, G_TYPE_OBJECT)
+
+static gpointer manager_object = NULL;
+
+#ifdef HAVE_PULSE
+
+static void
+sample_info_cb(pa_context *c, const pa_sample_info *i, int eol, void *userdata)
+{
+        pa_operation *o;
+
+        if (!i)
+                return;
+
+        g_debug("Found sample %s.", i->name);
+
+        /* We only flush those samples which have an XDG sound name
+         * attached, because only those originate from themeing  */
+        if (!(pa_proplist_gets(i->proplist, PA_PROP_EVENT_ID)))
+                return;
+
+        g_debug("Dropping sample %s from cache.", i->name);
+
+        if (!(o = pa_context_remove_sample(c, i->name, NULL, NULL))) {
+                g_debug("pa_context_remove_sample(): %s", pa_strerror(pa_context_errno(c)));
+                return;
+        }
+
+        pa_operation_unref(o);
+
+        /* We won't wait until the operation is actually executed to
+         * speed things up a bit.*/
+}
+
+static void
+flush_cache(void)
+{
+        pa_mainloop *ml = NULL;
+        pa_context *c = NULL;
+        pa_proplist *pl = NULL;
+        pa_operation *o = NULL;
+
+        g_debug("Flushing sample cache.");
+
+        if (!(ml = pa_mainloop_new())) {
+                g_debug("Failed to allocate pa_mainloop.");
+                goto fail;
+        }
+
+        if (!(pl = pa_proplist_new())) {
+                g_debug("Failed to allocate pa_proplist.");
+                goto fail;
+        }
+
+        pa_proplist_sets(pl, PA_PROP_APPLICATION_NAME, PACKAGE_NAME);
+        pa_proplist_sets(pl, PA_PROP_APPLICATION_VERSION, PACKAGE_VERSION);
+        pa_proplist_sets(pl, PA_PROP_APPLICATION_ID, "org.gnome.SettingsDaemon");
+
+        if (!(c = pa_context_new_with_proplist(pa_mainloop_get_api(ml), PACKAGE_NAME, pl))) {
+                g_debug("Failed to allocate pa_context.");
+                goto fail;
+        }
+
+        pa_proplist_free(pl);
+        pl = NULL;
+
+        if (pa_context_connect(c, NULL, PA_CONTEXT_NOAUTOSPAWN, NULL) < 0) {
+                g_debug("pa_context_connect(): %s", pa_strerror(pa_context_errno(c)));
+                goto fail;
+        }
+
+        /* Wait until the connection is established */
+        while (pa_context_get_state(c) != PA_CONTEXT_READY) {
+
+                if (!PA_CONTEXT_IS_GOOD(pa_context_get_state(c))) {
+                        g_debug("Connection failed: %s", pa_strerror(pa_context_errno(c)));
+                        goto fail;
+                }
+
+                if (pa_mainloop_iterate(ml, TRUE, NULL) < 0) {
+                        g_debug("pa_mainloop_iterate() failed.");
+                        goto fail;
+                }
+        }
+
+        /* Enumerate all cached samples */
+        if (!(o = pa_context_get_sample_info_list(c, sample_info_cb, NULL))) {
+                g_debug("pa_context_get_sample_info_list(): %s", pa_strerror(pa_context_errno(c)));
+                goto fail;
+        }
+
+        /* Wait until our operation is finished and there's nothing
+         * more queued to send to the server */
+        while (pa_operation_get_state(o) == PA_OPERATION_RUNNING || pa_context_is_pending(c)) {
+
+                if (!PA_CONTEXT_IS_GOOD(pa_context_get_state(c))) {
+                        g_debug("Connection failed: %s", pa_strerror(pa_context_errno(c)));
+                        goto fail;
+                }
+
+                if (pa_mainloop_iterate(ml, TRUE, NULL) < 0) {
+                        g_debug("pa_mainloop_iterate() failed.");
+                        goto fail;
+                }
+        }
+
+        g_debug("Sample cache flushed.");
+
+fail:
+        if (o) {
+                pa_operation_cancel(o);
+                pa_operation_unref(o);
+        }
+
+        if (c) {
+                pa_context_disconnect(c);
+                pa_context_unref(c);
+        }
+
+        if (pl)
+                pa_proplist_free(pl);
+
+        if (ml)
+                pa_mainloop_free(ml);
+}
+
+static gboolean
+flush_cb(GsdSoundSampleCacheManager *manager)
+{
+        flush_cache();
+        manager->priv->timeout = 0;
+        return FALSE;
+}
+
+static void
+trigger_flush(GsdSoundSampleCacheManager *manager)
+{
+
+        if (manager->priv->timeout)
+                g_source_remove(manager->priv->timeout);
+
+        /* We delay the flushing a bit so that we can coalesce
+         * multiple changes into a single cache flush */
+        manager->priv->timeout = g_timeout_add(500, (GSourceFunc) flush_cb, manager);
+}
+
+static void
+gconf_client_notify_cb(
+                GConfClient *client,
+                guint cnxn_id,
+                GConfEntry *entry,
+                GsdSoundSampleCacheManager *manager)
+{
+        g_debug("GConf dir changed");
+        trigger_flush(manager);
+}
+
+static gboolean
+register_config_callback(
+                GsdSoundSampleCacheManager *manager,
+                GError **error)
+{
+        GConfClient *client;
+
+        client = gconf_client_get_default();
+
+        gconf_client_add_dir(client, GCONF_SOUND_DIR, GCONF_CLIENT_PRELOAD_NONE, error);
+        g_return_val_if_fail(!error || !*error, FALSE);
+
+        manager->priv->gconf_notify = gconf_client_notify_add(client, GCONF_SOUND_DIR, (GConfClientNotifyFunc) gconf_client_notify_cb, manager, NULL, error);
+        g_return_val_if_fail(!error || !*error, FALSE);
+
+        g_object_unref(client);
+
+        return TRUE;
+}
+
+static void
+file_monitor_changed_cb(
+                GFileMonitor *monitor,
+                GFile *file,
+                GFile *other_file,
+                GFileMonitorEvent event,
+                GsdSoundSampleCacheManager *manager)
+{
+        g_debug("Theme dir changed");
+        trigger_flush(manager);
+}
+
+static gboolean
+register_directory_callback(
+                GsdSoundSampleCacheManager *manager,
+                const char *path,
+                GError **error)
+{
+
+        GFile *f;
+        GFileMonitor *m;
+
+        g_debug("registering directory monitor for %s", path);
+
+        f = g_file_new_for_path(path);
+        g_return_val_if_fail(f, FALSE);
+
+        m = g_file_monitor_directory(f, 0, NULL, error);
+        g_return_val_if_fail(m, FALSE);
+
+        g_signal_connect(m, "changed", G_CALLBACK(file_monitor_changed_cb), manager);
+
+        manager->priv->monitors = g_list_prepend(manager->priv->monitors, m);
+
+        g_object_unref(G_OBJECT(f));
+
+        return TRUE;
+}
+
+#endif
+
+gboolean
+gsd_sound_sample_cache_manager_start(
+                GsdSoundSampleCacheManager *manager,
+                GError **error)
+{
+
+#ifdef HAVE_PULSE
+        char *p, **ps, **k;
+        const char *env, *dd;
+#endif
+
+        g_debug("Starting sound sample cache manager");
+        gnome_settings_profile_start(NULL);
+
+#ifdef HAVE_PULSE
+
+        /* We listen for change of the selected theme ... */
+        register_config_callback(manager, NULL);
+
+        /* ... and we listen to changes of the theme base directories
+         * in $HOME ...*/
+
+        if ((env = g_getenv("XDG_DATA_HOME")) && *env == '/')
+                p = g_build_filename(env, "sounds", NULL);
+        else if (((env = g_getenv("HOME")) && *env == '/') || (env = g_get_home_dir()))
+                p = g_build_filename(env, ".local", "share", "sounds", NULL);
+        else
+                p = NULL;
+
+        if (p) {
+                register_directory_callback(manager, p, NULL);
+                g_free(p);
+        }
+
+        /* ... and globally. */
+        if (!(dd = g_getenv("XDG_DATA_DIRS")) || *dd == 0)
+                dd = "/usr/local/share:/usr/share";
+
+        ps = g_strsplit(dd, ":", 0);
+
+        for (k = ps; *k; k++)
+                register_directory_callback(manager, *k, NULL);
+
+        g_strfreev(ps);
+#endif
+
+        return TRUE;
+}
+
+void
+gsd_sound_sample_cache_manager_stop(
+                GsdSoundSampleCacheManager *manager)
+{
+        g_debug("Stopping sound sample cache manager");
+
+#ifdef HAVE_PULSE
+        if (manager->priv->gconf_notify != 0) {
+                GConfClient *client = gconf_client_get_default();
+
+                gconf_client_remove_dir(client, GCONF_SOUND_DIR, NULL);
+
+                gconf_client_notify_remove(client, manager->priv->gconf_notify);
+                manager->priv->gconf_notify = 0;
+
+                g_object_unref(client);
+        }
+
+        if (manager->priv->timeout) {
+                g_source_remove(manager->priv->timeout);
+                manager->priv->timeout = 0;
+        }
+
+        while (manager->priv->monitors) {
+                g_file_monitor_cancel(G_FILE_MONITOR(manager->priv->monitors->data));
+                g_object_unref(G_OBJECT(manager->priv->monitors->data));
+                manager->priv->monitors = g_list_delete_link(manager->priv->monitors, manager->priv->monitors);
+        }
+#endif
+}
+
+static void
+gsd_sound_sample_cache_manager_set_property(
+                GObject *object,
+                guint prop_id,
+                const GValue *value,
+                GParamSpec *pspec)
+{
+        GsdSoundSampleCacheManager *self;
+
+        self = GSD_SOUND_SAMPLE_CACHE_MANAGER(object);
+
+        switch (prop_id) {
+                default:
+                        G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
+                        break;
+        }
+}
+
+static void
+gsd_sound_sample_cache_manager_get_property(
+                GObject *object,
+                guint prop_id,
+                GValue *value,
+                GParamSpec *pspec)
+{
+        GsdSoundSampleCacheManager *self;
+
+        self = GSD_SOUND_SAMPLE_CACHE_MANAGER(object);
+
+        switch (prop_id) {
+                default:
+                        G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
+                        break;
+        }
+}
+
+static GObject *
+gsd_sound_sample_cache_manager_constructor(
+                GType type,
+                guint n_construct_properties,
+                GObjectConstructParam *construct_properties)
+{
+        GsdSoundSampleCacheManager *m;
+        GsdSoundSampleCacheManagerClass *klass;
+
+        klass = GSD_SOUND_SAMPLE_CACHE_MANAGER_CLASS(g_type_class_peek(GSD_TYPE_SOUND_SAMPLE_CACHE_MANAGER));
+
+        m = GSD_SOUND_SAMPLE_CACHE_MANAGER(G_OBJECT_CLASS(gsd_sound_sample_cache_manager_parent_class)->constructor(
+                                                           type,
+                                                           n_construct_properties,
+                                                           construct_properties));
+
+        return G_OBJECT(m);
+}
+
+static void
+gsd_sound_sample_cache_manager_dispose(GObject *object)
+{
+        GsdSoundSampleCacheManager *manager;
+
+        manager = GSD_SOUND_SAMPLE_CACHE_MANAGER(object);
+
+        gsd_sound_sample_cache_manager_stop(manager);
+
+        G_OBJECT_CLASS(gsd_sound_sample_cache_manager_parent_class)->dispose(object);
+}
+
+static void
+gsd_sound_sample_cache_manager_class_init(GsdSoundSampleCacheManagerClass *klass)
+{
+        GObjectClass   *object_class = G_OBJECT_CLASS(klass);
+
+        object_class->get_property = gsd_sound_sample_cache_manager_get_property;
+        object_class->set_property = gsd_sound_sample_cache_manager_set_property;
+        object_class->constructor = gsd_sound_sample_cache_manager_constructor;
+        object_class->dispose = gsd_sound_sample_cache_manager_dispose;
+        object_class->finalize = gsd_sound_sample_cache_manager_finalize;
+
+        g_type_class_add_private(klass, sizeof(GsdSoundSampleCacheManagerPrivate));
+}
+
+static void
+gsd_sound_sample_cache_manager_init(GsdSoundSampleCacheManager *manager)
+{
+        manager->priv = GSD_SOUND_SAMPLE_CACHE_MANAGER_GET_PRIVATE(manager);
+}
+
+static void
+gsd_sound_sample_cache_manager_finalize(GObject *object)
+{
+        GsdSoundSampleCacheManager *sound_sample_cache_manager;
+
+        g_return_if_fail(object != NULL);
+        g_return_if_fail(GSD_IS_SOUND_SAMPLE_CACHE_MANAGER(object));
+
+        sound_sample_cache_manager = GSD_SOUND_SAMPLE_CACHE_MANAGER(object);
+
+        g_return_if_fail(sound_sample_cache_manager->priv);
+
+        G_OBJECT_CLASS(gsd_sound_sample_cache_manager_parent_class)->finalize(object);
+}
+
+GsdSoundSampleCacheManager *
+gsd_sound_sample_cache_manager_new(void)
+{
+        if (manager_object) {
+                g_object_ref(manager_object);
+        } else {
+                manager_object = g_object_new(GSD_TYPE_SOUND_SAMPLE_CACHE_MANAGER, NULL);
+                g_object_add_weak_pointer(manager_object, (gpointer *) &manager_object);
+        }
+
+        return GSD_SOUND_SAMPLE_CACHE_MANAGER(manager_object);
+}
diff --git a/plugins/sound-sample-cache/gsd-sound-sample-cache-manager.h b/plugins/sound-sample-cache/gsd-sound-sample-cache-manager.h
new file mode 100644
index 0000000..7be3e96
--- /dev/null
+++ b/plugins/sound-sample-cache/gsd-sound-sample-cache-manager.h
@@ -0,0 +1,57 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2008 Lennart Poettering <lennart@poettering.net>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#ifndef __GSD_SOUND_SAMPLE_CACHE_MANAGER_H
+#define __GSD_SOUND_SAMPLE_CACHE_MANAGER_H
+
+#include <glib.h>
+#include <glib-object.h>
+
+G_BEGIN_DECLS
+
+#define GSD_TYPE_SOUND_SAMPLE_CACHE_MANAGER         (gsd_sound_sample_cache_manager_get_type())
+#define GSD_SOUND_SAMPLE_CACHE_MANAGER(o)           (G_TYPE_CHECK_INSTANCE_CAST((o), GSD_TYPE_SOUND_SAMPLE_CACHE_MANAGER, GsdSoundSampleCacheManager))
+#define GSD_SOUND_SAMPLE_CACHE_MANAGER_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), GSD_TYPE_SOUND_SAMPLE_CACHE_MANAGER, GsdSoundSampleCacheManagerClass))
+#define GSD_IS_SOUND_SAMPLE_CACHE_MANAGER(o)        (G_TYPE_CHECK_INSTANCE_TYPE((o), GSD_TYPE_SOUND_SAMPLE_CACHE_MANAGER))
+#define GSD_IS_SOUND_SAMPLE_CACHE_MANAGER_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE((k), GSD_TYPE_SOUND_SAMPLE_CACHE_MANAGER))
+#define GSD_SOUND_SAMPLE_CACHE_MANAGER_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS((o), GSD_TYPE_SOUND_SAMPLE_CACHE_MANAGER, GsdSoundSampleCacheManagerClass))
+
+typedef struct GsdSoundSampleCacheManagerPrivate GsdSoundSampleCacheManagerPrivate;
+
+typedef struct
+{
+        GObject parent;
+        GsdSoundSampleCacheManagerPrivate *priv;
+} GsdSoundSampleCacheManager;
+
+typedef struct
+{
+        GObjectClass parent_class;
+} GsdSoundSampleCacheManagerClass;
+
+GType gsd_sound_sample_cache_manager_get_type(void) G_GNUC_CONST;
+
+GsdSoundSampleCacheManager *gsd_sound_sample_cache_manager_new(void);
+gboolean gsd_sound_sample_cache_manager_start(GsdSoundSampleCacheManager *manager, GError **error);
+void gsd_sound_sample_cache_manager_stop(GsdSoundSampleCacheManager *manager);
+
+G_END_DECLS
+
+#endif /* __GSD_SOUND_SAMPLE_CACHE_MANAGER_H */
diff --git a/plugins/sound-sample-cache/gsd-sound-sample-cache-plugin.c b/plugins/sound-sample-cache/gsd-sound-sample-cache-plugin.c
new file mode 100644
index 0000000..9d9ab47
--- /dev/null
+++ b/plugins/sound-sample-cache/gsd-sound-sample-cache-plugin.c
@@ -0,0 +1,100 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2008 Lennart Poettering <lennart@poettering.net>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#include "config.h"
+
+#include <glib/gi18n-lib.h>
+#include <gmodule.h>
+
+#include "gnome-settings-plugin.h"
+#include "gsd-sound-sample-cache-plugin.h"
+#include "gsd-sound-sample-cache-manager.h"
+
+struct GsdSoundSampleCachePluginPrivate {
+        GsdSoundSampleCacheManager *manager;
+};
+
+#define GSD_SOUND_SAMPLE_CACHE_PLUGIN_GET_PRIVATE(object) (G_TYPE_INSTANCE_GET_PRIVATE((object), GSD_TYPE_SOUND_SAMPLE_CACHE_PLUGIN, GsdSoundSampleCachePluginPrivate))
+
+GNOME_SETTINGS_PLUGIN_REGISTER(GsdSoundSampleCachePlugin, gsd_sound_sample_cache_plugin)
+
+static void
+gsd_sound_sample_cache_plugin_init(GsdSoundSampleCachePlugin *plugin)
+{
+        plugin->priv = GSD_SOUND_SAMPLE_CACHE_PLUGIN_GET_PRIVATE(plugin);
+
+        g_debug("GsdSoundSampleCachePlugin initializing");
+
+        plugin->priv->manager = gsd_sound_sample_cache_manager_new();
+}
+
+static void
+gsd_sound_sample_cache_plugin_finalize(GObject *object)
+{
+        GsdSoundSampleCachePlugin *plugin;
+
+        g_return_if_fail(object != NULL);
+        g_return_if_fail(GSD_IS_SOUND_SAMPLE_CACHE_PLUGIN(object));
+
+        g_debug("GsdSoundSampleCachePlugin finalizing");
+
+        plugin = GSD_SOUND_SAMPLE_CACHE_PLUGIN(object);
+
+        g_return_if_fail(plugin->priv != NULL);
+
+        if (plugin->priv->manager != NULL)
+                g_object_unref(plugin->priv->manager);
+
+        G_OBJECT_CLASS(gsd_sound_sample_cache_plugin_parent_class)->finalize(object);
+}
+
+static void
+impl_activate(GnomeSettingsPlugin *plugin)
+{
+        GError *error = NULL;
+
+        g_debug("Activating sound_sample_cache plugin");
+
+        if (!gsd_sound_sample_cache_manager_start(GSD_SOUND_SAMPLE_CACHE_PLUGIN(plugin)->priv->manager, &error)) {
+                g_warning("Unable to start sound sample cache manager: %s", error->message);
+                g_error_free(error);
+        }
+}
+
+static void
+impl_deactivate(GnomeSettingsPlugin *plugin)
+{
+        g_debug("Deactivating sound sample cache plugin");
+        gsd_sound_sample_cache_manager_stop(GSD_SOUND_SAMPLE_CACHE_PLUGIN(plugin)->priv->manager);
+}
+
+static void
+gsd_sound_sample_cache_plugin_class_init(GsdSoundSampleCachePluginClass *klass)
+{
+        GObjectClass *object_class = G_OBJECT_CLASS(klass);
+        GnomeSettingsPluginClass *plugin_class = GNOME_SETTINGS_PLUGIN_CLASS(klass);
+
+        object_class->finalize = gsd_sound_sample_cache_plugin_finalize;
+
+        plugin_class->activate = impl_activate;
+        plugin_class->deactivate = impl_deactivate;
+
+        g_type_class_add_private(klass, sizeof(GsdSoundSampleCachePluginPrivate));
+}
diff --git a/plugins/sound-sample-cache/gsd-sound-sample-cache-plugin.h b/plugins/sound-sample-cache/gsd-sound-sample-cache-plugin.h
new file mode 100644
index 0000000..3aa3f49
--- /dev/null
+++ b/plugins/sound-sample-cache/gsd-sound-sample-cache-plugin.h
@@ -0,0 +1,59 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2008 Lennart Poettering <lennart@poettering.net>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#ifndef __GSD_SOUND_SAMPLE_CACHE_PLUGIN_H__
+#define __GSD_SOUND_SAMPLE_CACHE_PLUGIN_H__
+
+#include <glib.h>
+#include <glib-object.h>
+#include <gmodule.h>
+
+#include "gnome-settings-plugin.h"
+
+G_BEGIN_DECLS
+
+#define GSD_TYPE_SOUND_SAMPLE_CACHE_PLUGIN                (gsd_sound_sample_cache_plugin_get_type())
+#define GSD_SOUND_SAMPLE_CACHE_PLUGIN(o)                  (G_TYPE_CHECK_INSTANCE_CAST((o), GSD_TYPE_SOUND_SAMPLE_CACHE_PLUGIN, GsdSoundSampleCachePlugin))
+#define GSD_SOUND_SAMPLE_CACHE_PLUGIN_CLASS(k)            (G_TYPE_CHECK_CLASS_CAST((k), GSD_TYPE_SOUND_SAMPLE_CACHE_PLUGIN, GsdSoundSampleCachePluginClass))
+#define GSD_IS_SOUND_SAMPLE_CACHE_PLUGIN(o)               (G_TYPE_CHECK_INSTANCE_TYPE((o), GSD_TYPE_SOUND_SAMPLE_CACHE_PLUGIN))
+#define GSD_IS_SOUND_SAMPLE_CACHE_PLUGIN_CLASS(k)         (G_TYPE_CHECK_CLASS_TYPE((k), GSD_TYPE_SOUND_SAMPLE_CACHE_PLUGIN))
+#define GSD_SOUND_SAMPLE_CACHE_PLUGIN_GET_CLASS(o)        (G_TYPE_INSTANCE_GET_CLASS((o), GSD_TYPE_SOUND_SAMPLE_CACHE_PLUGIN, GsdSoundSampleCachePluginClass))
+
+typedef struct GsdSoundSampleCachePluginPrivate GsdSoundSampleCachePluginPrivate;
+
+typedef struct
+{
+        GnomeSettingsPlugin parent;
+        GsdSoundSampleCachePluginPrivate *priv;
+} GsdSoundSampleCachePlugin;
+
+typedef struct
+{
+        GnomeSettingsPluginClass parent_class;
+} GsdSoundSampleCachePluginClass;
+
+GType gsd_sound_sample_cache_plugin_get_type(void) G_GNUC_CONST;
+
+/* All the plugins must implement this function */
+G_MODULE_EXPORT GType register_gnome_settings_plugin(GTypeModule *module);
+
+G_END_DECLS
+
+#endif /* __GSD_SOUND_SAMPLE_CACHE_PLUGIN_H__ */
diff --git a/plugins/sound-sample-cache/sound-sample-cache.gnome-settings-plugin.in b/plugins/sound-sample-cache/sound-sample-cache.gnome-settings-plugin.in
new file mode 100644
index 0000000..f31e6b7
--- /dev/null
+++ b/plugins/sound-sample-cache/sound-sample-cache.gnome-settings-plugin.in
@@ -0,0 +1,8 @@
+[GNOME Settings Plugin]
+Module=sound-sample-cache
+IAge=0
+_Name=Sound Sample Cache
+_Description=Sound Sample Cache plugin
+Authors=Lennart Poettering
+Copyright=Copyright © 2008
+Website=
-- 
1.5.6.4

